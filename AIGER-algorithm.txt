Given specfication ϕ(I,O,D), where I=input, O=independent output D=dependent vars

function Synthesis(ϕ, I, O):
    1. Aϕ <- NBA of ϕ(I,O)
    2. D = FindDependentVairables(Aϕ)
    3. Aϕ' = RemoveAP(Aϕ, D)
    
    4. AigerOfIndependent = SpotSynthesis(Aϕ')
    5. AigerOfDependents = SynthesisDependentAiger(Aϕ,I,O - D, D)

    # Merging both Aiger to final synthesis tool
    6. For indepdent_out in O - D:
        6.1. Connect the output of `indepdent_out` in AigerOfIndependent as an input to AigerOfDependents
    7. Connect all inputs in I as inputs to AigerOfDependents.
    
    8. return AigerOfIndependent



function SynthesisDependentAiger(Aϕ,I,O,D):
    1. Aϕ <- DeterminizeNBA(ϕ)
    2. Aϕ_AIGER <- DBA_to_AIGER(Aϕ, latches=States(Aϕ), Input=I ∪ O, Output=D)
    3. all_Aϕ_AIGER = []
    
    # For each state generates AIGER, and duplicate it as number of edges ad restrict h
    4. for each s in states(Aϕ):
        4.1 s_aiger <- Duplicate(Aϕ_AIGER)
        4.2 s_aiger <- Restrict the latches of the states to the corresponding "s" latches.
        4.2 K = round_up(lg_2( #Edges ))   # What are the relevant H_ap
        4.3 Remove all latches H_{k+1}, ..., H_m    # m = total of "h" variables
        4.4 for each h_config in 2^{K}:
            4.4.1. aiger <- duplicate(s_aiger)
            4.4.2. aiger <- Restrict h1,...,h_{k} according to h_config
            4.4.3. all_Aϕ_AIGER.add(aiger)

    # Creating the final AIGER - This part I don't understand completely - how to merge all AIGERs
    5. Create an AIGER: Input = I ∪ O, Output=D, latches=States(Aϕ).


function MaximumRepeatedBDD( List of BBDs ):
    Returns the BDD which appears the most in the list of BDDs, and how many times it appears



function DeterminizeNBA(ϕ):
    1. Aϕ <- NBA of ϕ(I,O,D)
    2. M <- maximum { MaximumRepeatedBDD( Out(s) ) | s ∈ States(Aϕ) } 
    3. Add APs: h_1, ..., h_k     k <- round_up(lg_2(M))

    # Add the AP: h_1,...,h_k to the NBW Aϕ
    4. For each s ∈ States(Aϕ):
        4.1) GroupedBDDs <- GroupByBDD( Out(S) )   # A key-value, where key=BDD, value=All edges with this BDD

        4.2) For each (BDD, Edges) ∈ GroupedBDDs:
            4.2.1) If |Edges| == 1: SKIP
            4.2.2) relevants_AP_h = round_up(lg_2( #Edges ))    # Only h1,...,h_{round_up(lg_2( #Edges ))} are relevant
            4.2.3) mask = 0
            4.2.4) for B in Edges:
                    for i ∈ [1, relevants_AP_h]:
                        if isKthBitOn(mask, i):
                            B = B & h_i # Add h_i has AP
                        else:
                            B = B & not(h_i) # Add \neg h_i has AP

                    mask += 1


My gaps to fulfiil before implementing:
1. I didn't find a function which converts DBA to AIGER in Spot, I'm still searching for a one
2. 
